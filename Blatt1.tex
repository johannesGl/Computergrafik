\documentclass[12pt]{article} 
\usepackage{german} 
\usepackage[utf8]{inputenc} 
\usepackage{latexsym} 
\usepackage{amsfonts} 
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{MnSymbol}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{wasysym}
\usepackage{stmaryrd}
\usepackage{makeidx}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage[onehalfspacing]{setspace}
\usepackage[headsepline]{scrpage2}
\usepackage{enumerate}
\pagestyle{plain}
\pagestyle{scrheadings}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}

\lstset{language = Java, breaklines = true, showstringspaces = false}

 %Titel
\begin{document}
\begin{center}
 \textbf{\Large Computergrafik Blatt 1}\\
 \emph{Anton Zickenberg, Johannes Gleichauf}
\end{center}

\section*{Aufgabe 1}
\includegraphics*[scale=0.165]{Screenshot.png}

\section*{Aufgabe 2}
\begin{enumerate}[a)]
\item int a = 2; //Integer-Variable a\\ 
	  int *pa = $\&$a ; //Pointer auf Variable a\\ 
	  a++; //Was steht in Variable a?\\ 
	  Der Wert der Variable ist nun 3\\
	  \\	  
	  (*pa)++; //Was steht jetzt in Variable a?\\ 
	  Der Wert der Variable ist nun 4\\
	  \\
	  *pa = 0; //Welchen Wert hat Variable a?\\
	  Der Wert der Variable ist nun 0\\
	  \\ 
	  pa++; //Was bewirkt dieses Statement?\\ 
	  		//Warum ist es problematisch?\\
\item 
\begin{enumerate}[1.]
\item Ein Pointer zeigt auf den Wert einer Speicheradresse. Eine Referenz ($\&$-Operator) besitzt die Speicheradresse einer Variablen. 
\item Pointer k\"onnen NULL sein, Referenzen nicht.
\item Pointer k\"onnen von einem Objekt auf ein anderes Umgeh\"angt werden, Referenzen zeigen immer auf das gleiche Objekt
\end{enumerate}
\item \begin{lstlisting}
void functionA (int param1, int param2);
void functionA (int &param1, int &param2);
void functionA (int *param1, int *param2);
\end{lstlisting}  
Die erste Methode bekommt als Übergabeparameter zwei Integer. Die zweite bekommt zwei Integer Referenzen. Die dritte bekommt Integer pointer.\\
\\
Wenn man in einem \emph{Call-by-Value} Aufruf den Wert des Values \"andert, dann wird der Wert nur innerhalb der Funktion gen\"andert, jedoch ist der neue Wert nicht au{\ss}erhalb der Funktion verf\"ugbar.\\
In einem \emph{Call-by-Reference} Aufruf, wird beim \"andern des Wertes der Wert der Referenz ge\"andert, dieser ist somit auch au{\ss}erhalb der Funktion durch Zugriff auf die Referenz erreichbar.\\
Anwendung \emph{Call-by-Value}:\\
Ein mögliches Szenario wäre die add (a+b) Funktion. Da die Übergabeparameter in der Funktion nicht verändert werden, ist keine Referenz nötig.\\
\emph{Call-by-Reference}:\\
Ein mögliches Szenario wäre ein Sortieralgorithmus auf einem Array. Damit von überall auf das sortierte Array zugegriffen werden kann, ohne weiteren Speicher mit zusätzlichen Variablen zu benötigen.
\end{enumerate}

\section*{Aufgabe 3}
Der Unterschied von Bild (a) zu Bild (b) ist, dass die Abtastpunkte in Bild (a) geordnet sind, w\"ahrend sie in Bild (b) ungeordnet sind.\\
Somit entsteht in Bild (a) ein geordnetese Muster, w\"ahrend in Bild (b) die Funktionen nicht geordnet \"ubereinander gelegt werden k\"onnen, und somit das Muster nur vermindert zu erkennne ist. 

\end{document}
